{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Maneesh Gupta NVSS","text":"","tags":["intro"]},{"location":"#introduction","title":"Introduction","text":"<p>Hi, my name is Maneesh Gupta Nalluru. I am currently working as SDE1 - backend developer at ShipRocket Omuni. </p>","tags":["intro"]},{"location":"#education","title":"Education","text":"<ul> <li> <p> M.Tech from IIIT Hyderabad</p> <p>Marks: 8.4/10</p> <p>Year of Passing:2023</p> <p>Course: CSE</p> </li> <li> <p> B.Tech from Sri Venkateswara University</p> <p>Marks: 8.3/10</p> <p>Year of Passing:2021</p> <p>Course: CSE</p> </li> <li> <p> Senior Secondary from Ratnam Junior College</p> <p>Marks: 979 / 1000</p> <p>Year of Passing : 2017</p> <p>Course: MPC</p> </li> <li> <p> Secondary from Ratnam High School</p> <p>Marks: 10/10</p> <p>Year of Passing:2015</p> </li> </ul>","tags":["intro"]},{"location":"#skills","title":"Skills","text":"","tags":["intro"]},{"location":"#tools","title":"Tools","text":"","tags":["intro"]},{"location":"Codes/","title":"Hello","text":"<p>How are you?</p>"},{"location":"Codes/sample/","title":"Some Sample Codes","text":"bubble_sort.py<pre><code>def bubble_sort(items):\n    for i in range(len(items)):\n        for j in range(len(items) - 1 - i):\n            if items[j] &gt; items[j + 1]:\n                items[j], items[j + 1] = items[j + 1], items[j]\n</code></pre>"},{"location":"Codes/sample/#content-tabs-with-code-blocks","title":"Content tabs with code blocks","text":"CC++ <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\nprintf(\"Hello world!\\n\");\nreturn 0;\n}\n</code></pre> <pre><code>#include &lt;iostream&gt;\n\nint main(void) {\nstd::cout &lt;&lt; \"Hello world!\" &lt;&lt; std::endl;\nreturn 0;\n}\n</code></pre>"},{"location":"Codes/sample/#icons-and-emojs","title":"Icons and Emojs","text":""},{"location":"Codes/Leetcode/Buy_And_Sell_Stock/","title":"LC714 - Buy and Sell Stocks With Transaction Fee","text":"","tags":["Leetcode"]},{"location":"Codes/Leetcode/Buy_And_Sell_Stock/#problem-statement","title":"Problem Statement","text":"","tags":["Leetcode"]},{"location":"Codes/Leetcode/Buy_And_Sell_Stock/#solution","title":"Solution","text":"buy_sell_transaction_fee.cpp<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nint maximumProfit(int n,int fee,vector&lt;int&gt;&amp;values){\n    int aheadNotBuy,aheadBuy,curBuy,curNotBuy;\n                    aheadBuy=0;\n                    aheadNotBuy=0;\n    for(int ind=n-1;ind&gt;=0;ind--){\n       // sell\n       curNotBuy=max(values[ind]+aheadBuy,\n                                0+aheadNotBuy);\n        // buy\n       curBuy=max(-values[ind]-fee+aheadNotBuy,\n                                 0+aheadBuy);\n         aheadBuy=curBuy;\n         aheadNotBuy=curNotBuy;\n\n    }\n    return aheadBuy;\n}\n</code></pre> <p> This the title</p> <ul> <li>list under lists</li> <li>under lists</li> </ul>","tags":["Leetcode"]},{"location":"DSA/","title":"DSA Topics","text":""},{"location":"DSA/Graphs/","title":"Graph Topics","text":"<ol> <li>DFS</li> <li>BFS</li> <li>Directed Graph<ol> <li>Cycle Detection</li> </ol> </li> <li>Undirected Graph<ol> <li>Cycle Detection</li> </ol> </li> <li>Kosaraju Algorithm</li> <li>Tarjan's Algorithm</li> <li>Strongly connected components</li> <li>Prim's Algorithm</li> <li>Krushkal's Algorithm</li> <li>Dijkstra's Algorithm</li> </ol>","tags":["dsa","graph"]},{"location":"DSA/Graphs/BFS/","title":"BFS","text":"<p>A sample BFS code in C++.</p> BFS.cpp<pre><code>#include&lt;bits/stdc++.h&gt; \nusing namespace std; \n\nvoid BFS(vector&lt;int&gt; adj[], int V, int s) \n{ \n    bool visited[V]; \n    for(int i = 0; i &lt; V; i++) \n        visited[i] = false; \n\n    queue&lt;int&gt;  q;\n\n    visited[s] = true; \n    q.push(s); \n\n    while(q.empty()==false) \n    { \n        int u = q.front(); \n        q.pop();\n        cout &lt;&lt; u &lt;&lt; \" \"; \n\n        for(int v:adj[u]){\n            if(visited[v]==false){\n                visited[v]=true;\n                q.push(v);\n            }\n        } \n    } \n} \n\nvoid addEdge(vector&lt;int&gt; adj[], int u, int v){\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n}\n\nint main() \n{ \n    int V=5;\n    vector&lt;int&gt; adj[V];\n    addEdge(adj,0,1); \n    addEdge(adj,0,2); \n    addEdge(adj,1,2); \n    addEdge(adj,2,3); \n    addEdge(adj,1,3);\n    addEdge(adj,3,4);\n    addEdge(adj,2,4);\n\n    cout &lt;&lt; \"Following is Breadth First Traversal: \"&lt;&lt; endl; \n    BFS(adj,V,0); \n\n    return 0; \n} \n</code></pre>"},{"location":"DSA/Trees/","title":"Trees","text":"","tags":["dsa","tree"]},{"location":"DSA/Trees/#types-of-trees","title":"Types of Trees","text":"<ul> <li>Trees</li> <li>n-ary Trees</li> <li>Segment Trees</li> <li>Fenwick Trees</li> <li>Binary Trees</li> <li>Binary Search Trees</li> <li>Balanced Binary Search Trees</li> <li>Red - Black Trees</li> </ul>","tags":["dsa","tree"]},{"location":"SD/","title":"Low Level Design Roadmap","text":""},{"location":"SD/#design-patterns-to-be-covered","title":"Design Patterns to be Covered:","text":"<ol> <li>Strategy Pattern</li> <li>Observer Pattern</li> <li>Factory Pattern</li> <li>Abstract Factory Pattern</li> <li>Chain of Responsibility Pattern</li> <li>Command Pattern</li> <li>Adapter Pattern</li> <li>Prototype Pattern</li> <li>Decorator Pattern</li> <li>Template Method Pattern</li> <li>Null Object Pattern</li> <li>Singleton Pattern</li> <li>Proxy Pattern</li> <li>State Pattern</li> <li>Builder Pattern</li> <li>Bridge Pattern</li> <li>Flyweight Pattern</li> <li>Composite Pattern</li> <li>Facade Pattern</li> <li>Mediator Pattern</li> <li>Visitor Pattern</li> <li>Iterator Pattern</li> <li>Interpreter Pattern</li> <li>Memento Pattern</li> </ol>"},{"location":"SD/#popular-interview-questions-to-be-covered","title":"Popular Interview Questions to be Covered:","text":"<ol> <li>S.O.L.I.D Principles</li> <li>Design Notify-Me Button Functionality</li> <li>Design Pizza Billing System</li> <li>Design Parking Lot</li> <li>Design Snake n Ladder Game</li> <li>Design Elevator System</li> <li>Design Car Rental System</li> <li>Design Logging System</li> <li>Design Tic-Tac-Toe Game</li> <li>Design BookMyShow &amp; Concurrency Handling</li> <li>Design Vending Machine</li> <li>Design ATM</li> <li>Design Chess Game</li> <li>Design File System</li> <li>Design Splitwise</li> <li>Design Splitwise Simplify Algorithm / Optimal Accounting Balancing</li> <li>Design CricBuzz / CricketInfo</li> <li>Design True Caller</li> <li>Design Car Booking Service like Ola, Uber</li> <li>Design Online Hotel Booking System</li> <li>Design Library Management System</li> <li>Design Traffic Light System</li> <li>Design Meeting Scheduler</li> <li>Design Online Voting System</li> <li>Design Inventory Management System / Design Order Management System</li> <li>Design Cache Mechanism</li> <li>Design LinkedIn</li> <li>Design Amazon</li> <li>Design Airline Management System</li> <li>Design Stock Exchange System</li> <li>Design Learning Management System</li> <li>Design a Calendar Application</li> <li>Design (LLD) Payment System</li> <li>Design (LLD) Chat Based System</li> <li>Design Food Delivery App like Swiggy and Zomato</li> <li>Design Community Discussion Platform</li> <li>Design Restaurant Management System</li> </ol>"},{"location":"SD/HLD/caching/","title":"Caching Strategy","text":"<p>What is the need for caching?</p> <ol> <li>Caching is a technique to store frequently used data in a fast access memory rather than accessing data every time from a slow access memory.</li> <li>This makes our system fast.</li> <li>It helps to reduce latency.</li> <li>It also helps to achieve the fault tolerance.</li> <li>There are different types of caching present at different layer of the system like:<ol> <li>Client side caching (Browser caching)</li> <li>CDN (used to store the static data)</li> <li>Load balancer</li> <li>Server side application caching (like redis etc.)</li> </ol> </li> </ol> <pre><code>flowchart LR\n        DB[(DB)]\n    Client--&gt;LoadBalancer --&gt; AppServer --&gt; Cache:::foo --&gt; DB\n    classDef foo stroke:#f00</code></pre> <p>Why single cache is not recommended? Need for distributed caching?</p> <ol> <li>Possibility for single point failure</li> <li>Scalability (After some point we can\u2019t scale it up)</li> </ol> <p>How distributed caching works?</p> <ol> <li>We use consistent hashing technique to use them. </li> <li>There is a pool of cache servers</li> </ol>","tags":["hld","cache"]},{"location":"SD/HLD/caching/#cache-aside","title":"Cache Aside","text":"<p>Application first check the cache.</p> <p>If data found in the cache, it is a cache hit and data is returned to the client.</p> <p>If data is not found in cache, it is a cache miss, application fetch the data from the DB, store it back to cache and data is returned to the client.</p> <pre><code>sequenceDiagram\nautonumber\n    Client-&gt;&gt; Server: Read request\n    Note over Client: GET call\n      Server-&gt;&gt;Cache: Read from cache\n    alt is cache hit\n        Cache-&gt;&gt;Server: Found in cache\n    else is cache miss\n         Cache-&gt;&gt;Server: Not found in cache\n         Server-&gt;&gt;DB: Fetch data from DB\n         Server-&gt;&gt;Cache: Write into cache\n    end\n    Server-&gt;&gt;Client:Send Response\n</code></pre> <p>Pros:</p> <ol> <li>Good approach for heavy read applications.</li> <li>Even cache is down, request will not fail, as it will fetch the data from DB.</li> <li>Cache document data structure can be different than the data structure (how DB stores) present in DB. (Both are independent).</li> </ol> <p>Cons:</p> <ol> <li>For new data read, there will always be CACHE-MISS first. (to resolve this, generally we can pre-hit the cache).</li> <li>Without appropriate caching is not used during write operation, There is a chance of inconsistency between cache and DB.</li> </ol>","tags":["hld","cache"]},{"location":"SD/HLD/caching/#read-through-cache","title":"Read through cache","text":"<ol> <li>Application first check the cache.</li> <li>If data found in cache, it is called cache hit and data is returned to the client.</li> <li>If data is not found in cache, it is called cache miss. Cache library itself fetch the data from DB, store it back to cache and data is returned to the application.</li> </ol> <pre><code>sequenceDiagram\nautonumber\n    Client-&gt;&gt; Server: Read request\n    Note over Client: GET call\n      Server-&gt;&gt;Cache: Read from cache\n    alt is cache hit\n        Cache-&gt;&gt;Server: Found in cache\n    else is cache miss\n         Cache-&gt;&gt;DB: Not found in cache, fetch from DB\n         DB-&gt;&gt;Cache: Write into cache\n         Cache-&gt;&gt;Server: send to server\n    end\n    Server-&gt;&gt;Client:Send Response</code></pre> <p>Pros:</p> <ol> <li>Good approach for heavy read applications.</li> <li>Logic of fetching the data from the DB and updating cache is seperated from the application.</li> </ol> <p>Cons:</p> <ol> <li>For new data read, there will always be CACHE-MISS first (to resolve this, generally we can pre-hit the cache).</li> <li>If appropriate caching is not used during write operation, then there is a chance of inconsistency between cache and DB.</li> <li>Cache document structure should be same as DB table.</li> </ol>","tags":["hld","cache"]},{"location":"SD/HLD/caching/#write-around-cache","title":"Write around cache","text":"<ol> <li>Directly writes data into the DB.</li> <li>It do not update the cache.</li> </ol> <pre><code>sequenceDiagram\nautonumber\n    Client-&gt;&gt; Server: Write request\n    Note over Client: PUT/PATCH/POST call\n      Server-&gt;&gt;DB: Directly write to DB.\n      Server-&gt;&gt;Cache: Invalidate the data in cache.\n    Server-&gt;&gt;Client:Send Response</code></pre> <p>Pros:</p> <ol> <li>Good approach for heavy read applications.</li> <li>Resolves inconsistency problem between cache and DB.</li> </ol> <p>Cons:</p> <ol> <li>For new data read, there will always be CACHE-MISS first (to resolve this, generally we can pre-hit the cache).</li> <li>If DB is down, write operation will fail.</li> </ol>","tags":["hld","cache"]},{"location":"SD/HLD/caching/#write-through-cache","title":"Write Through Cache","text":"<ol> <li>First writes data into the cache.</li> <li>In synchronous way writes data into the DB.</li> <li>If DB fails, then cache should also be rolled back.</li> </ol> <pre><code>sequenceDiagram\nautonumber\n    Client-&gt;&gt; Server: Write request\n    Note over Client: PUT/PATCH/POST call\n    critical should be made in synchronous way\n      Server-&gt;&gt;Cache: First write to Cache.\n      Server-&gt;&gt;DB: Then, write into DB.\n      end\n    Server-&gt;&gt;Client:Send Response</code></pre> <p>Pros:</p> <ol> <li>Cache and DB always remain consistent.</li> <li>Cache hit chance increases a lot.</li> </ol> <p>Cons:</p> <ol> <li>Alone it is not useful, it will increase the latency. (thats why it is always used with read through or cache aside cache).</li> <li>2 Phase commit need to be supported with this to maintain the transactional property.</li> <li>If DB is down, write operation will fail. ( this not fully fault tolerant)</li> </ol>","tags":["hld","cache"]},{"location":"SD/HLD/caching/#write-back-behind-cache","title":"Write back (behind) cache","text":"<ol> <li>First writes data into the cache.</li> <li>Then in asynchronous writes data into the DB.</li> </ol> <pre><code>sequenceDiagram\nautonumber\n    Client-&gt;&gt; Server: Write request\n    Note over Client: PUT/PATCH/POST call\n\n      Server-&gt;&gt;Cache: First write to Cache.\n      Server-&gt;&gt;Queue: Then, push the message to queue.\n      critical happens in asynchronous way\n      Queue-&gt;&gt;DB: Write into DB\n      Server-&gt;&gt;Client:Send Response\n      end</code></pre> <p>Pros:</p> <ol> <li>Good for write heavy application.</li> <li>Improves the write operation latency as writing into the DB happens asynchronously.</li> <li>Cache hit chance increases a lot.</li> <li>Gives much better performance when used with read through cache.</li> <li>Even if DB fails, write operation will still works.</li> </ol> <p>Cons:</p> <ol> <li>If data is removed from cache and DB write still not happens, then there is a chance of an issue. ( it is handled by keeping the TAT of cache little higher like 2 days)</li> </ol>","tags":["hld","cache"]},{"location":"SD/HLD/concurrency/","title":"Concurrency","text":"<p>What is DB Locking?</p> <p>DB locking help us to make sure that not other transaction update the locked rows.</p> Lock Type Another Shared Lock Another Exclusive Lock Have Shared Lock Yes No Have Exclusive Lock No No <p>What are the isolation level present?</p> Isolation level Dirty Read Possible Non Repeatable Read Possible Phantom Read Possible Read Uncommitted Yes Yes Yes Read Committed No Yes Yes Repeatable Read No No Yes Serializable No No No <p>Concurrency increases from bottom to top.</p> <p>Consistency increases from top to bottom.</p> Isolation Level Locking Strategy Read Uncommitted Read : No lock acquired Write: No lock acquired Read Committed Read: Shared lock acquired and released as soon as read is done. Write: Exclusive lock acquired and keep till the end of the transaction. Repeatable Read Read: Shared lock is acquired and released only at the end of the transaction. Write: Exclusive lock is acquired and released only at the end of the transaction. Serializable Same as repeatable read locking strategy + apply range lock and lock is release only at the end of the transaction.","tags":["hld","concurrency"]},{"location":"SD/HLD/load-balancing/","title":"Load Balancing","text":"<pre><code>mindmap\n  root((LBA))\n    Static\n      Round Robin\n      Weighted Round Robin\n      IP Hash\n    Dynamic\n      Least Connection\n      Weighted Least Connection\n      Least Response Time</code></pre>","tags":["hld","loadbalancing"]},{"location":"SD/LLD/","title":"LLD","text":""},{"location":"SD/LLD/solid/","title":"SOLID Principles","text":""},{"location":"SD/LLD/solid/#s-single-responsibility-principle","title":"S - Single Responsibility Principle","text":"<p>A class should have only one reason to change.</p> <p>Martin defines a responsibility as a\u00a0reason to change, and concludes that a class or module should have one, and only one, reason to be changed (e.g. rewritten).</p> <p>As an example, consider a module that compiles and prints a report. Imagine such a module can be changed for two reasons. First, the content of the report could change. Second, the format of the report could change. These two things change for different causes. The single responsibility principle says that these two aspects of the problem are really two separate\u00a0responsibilities, and should, therefore, be in separate classes or modules. It would be a bad design to\u00a0couple\u00a0two things that change for different reasons at different times.</p> <p>The reason it is important to keep a class focused on a single concern is that it makes the class more robust. Continuing with the foregoing example, if there is a change to the report compilation process, there is a greater danger that the printing code will break if it is part of the same class. Taken From.</p>"},{"location":"SD/LLD/solid/#o-open-closed-principle","title":"O - Open Closed Principle","text":"<p>Open for extension closed for modification. A class which is throughly tested and live in production. Then it is not good to modify the class. Instead one can extend the class and do necessary modification.</p> <p>A class is closed, since it may be compiled, stored in a library,\u00a0baselined, and used by client classes. But it is also open, since any new class may use it as parent, adding new features. When a descendant class is defined, there is no need to change the original or to disturb its clients. </p> <p>https://en.wikipedia.org/wiki/Open\u2013closed_principle</p>"},{"location":"SD/LLD/solid/#l-liskov-substitution-principle","title":"L - Liskov Substitution Principle","text":"<p>When we substitute the parent class objects with the child class objects then the program should work without breaking.</p> <ol> <li>Definition: The Liskov Substitution Principle states that objects of a superclass should be replaceable with objects of a subclass without affecting the correctness of the program.</li> <li>Key Idea: Subtypes must be able to fulfill the contract of their base types, ensuring that derived classes can be used interchangeably with their base classes without introducing errors.</li> <li>Purpose: To maintain reliable and predictable behavior in an object-oriented system by ensuring that subclass objects can substitute their superclass objects seamlessly.</li> </ol> <pre><code>classDiagram\n    class Bird {\n        +fly() : void\n    }\n\n    Bird &lt;|-- Penguin\n\n    class Penguin {\n        +fly() : void\n    }\n</code></pre> <pre><code>// Bird.java\npublic class Bird {\n    public void fly() {\n        System.out.println(\"Flying\");\n    }\n}\n\n// Penguin.java\npublic class Penguin extends Bird {\n    @Override\n    public void fly() {\n        throw new UnsupportedOperationException(\"Penguins can't fly\");\n    }\n}\n\n// Main.java\npublic class Main {\n    public static void main(String[] args) {\n        Bird bird = new Bird();\n        Bird penguin = new Penguin();\n\n        bird.fly();       // Works fine\n        penguin.fly();    // Throws exception, violating LSP\n    }\n}\n</code></pre> <pre><code>classDiagram\n    class Bird {\n        +eat() : void\n    }\n\n    class Flyable {\n        &lt;&lt;interface&gt;&gt;\n        +fly() : void\n    }\n\n    Bird &lt;|-- Sparrow\n    Bird &lt;|-- Penguin\n    Sparrow ..|&gt; Flyable\n\n    class Sparrow {\n        +eat() : void\n        +fly() : void\n    }\n\n    class Penguin {\n        +eat() : void\n    }\n</code></pre> <pre><code>// Bird.java\npublic abstract class Bird {\n    public abstract void eat();\n}\n\n// Flyable.java\npublic interface Flyable {\n    void fly();\n}\n\n// Sparrow.java\npublic class Sparrow extends Bird implements Flyable {\n    @Override\n    public void eat() {\n        System.out.println(\"Sparrow is eating\");\n    }\n\n    @Override\n    public void fly() {\n        System.out.println(\"Sparrow is flying\");\n    }\n}\n\n// Penguin.java\npublic class Penguin extends Bird {\n    @Override\n    public void eat() {\n        System.out.println(\"Penguin is eating\");\n    }\n\n    // Penguins do not implement Flyable\n}\n\n// Main.java\npublic class Main {\n    public static void main(String[] args) {\n        Bird sparrow = new Sparrow();\n        Bird penguin = new Penguin();\n\n        sparrow.eat();     // Works fine\n        ((Flyable) sparrow).fly();  // Works fine\n\n        penguin.eat();     // Works fine\n        // penguin cannot fly, no cast to Flyable, adhering to LSP\n    }\n}\n</code></pre>"},{"location":"SD/LLD/solid/#i-interface-segregation-principle","title":"I - Interface Segregation Principle","text":"<p>Reference</p> <p>This principle was first defined by Robert C. Martin as: \u201cClients should not be forced to depend upon interfaces that they do not use\u201c.</p> <p>The goal of this principle is to\u00a0reduce the side effects of using larger interfaces by breaking application interfaces into smaller ones. It\u2019s similar to the\u00a0Single Responsibility Principle, where each class or interface serves a single purpose.</p> <p>Precise application design and correct abstraction is the key behind the Interface Segregation Principle.\u00a0Though it\u2019ll take more time and effort in the design phase of an application and might increase the code complexity, in the end, we get a flexible code.</p> Before <pre><code>classDiagram\n    class IPayment {\n        +void initiatePayments()\n        +Object status()\n        +List&lt;Object&gt; getPayments()\n        +void intiateLoanSettlement()\n        +void initiateRePayment()\n    }\n    class LoanPayment {\n        +void initiatePayments()\n        +Object status()\n        +List&lt;Object&gt; getPayments()\n        +void intiateLoanSettlement()\n        +void initiateRePayment()\n    }\n    class BankPayment {\n        +void initiatePayments()\n        +Object status()\n        +List&lt;Object&gt; getPayments()\n        +void intiateLoanSettlement() UnsupportedOperationException\n        +void initiateRePayment() UnsupportedOperationException\n    }\n\n    IPayment &lt;|-- BankPayment : implements\n    IPayment &lt;|-- LoanPayment : implements\n</code></pre> After <pre><code>classDiagram\n\n    class IPayment {\n        +Object status()\n        +List&lt;Object&gt; getPayments()\n    }\n    class IBank {\n        +void initiatePayments()\n    }\n    class ILoan {\n        +void initiateLoanSettlement()\n        +void initiateRePayment()\n    }\n    class BankPayment {\n        +void initiatePayments()\n        +Object status()\n        +List&lt;Object&gt; getPayments()\n    }\n    class LoanPayment {\n        +void initiateLoanSettlement()\n        +void initiateRePayment()\n        +Object status()\n        +List&lt;Object&gt; getPayments()\n    }\n\n    IPayment &lt;|.. IBank : extends\n    IPayment &lt;|.. ILoan : extends\n    IBank &lt;|-- BankPayment  : implements\n    ILoan &lt;|-- LoanPayment  : implements</code></pre>"},{"location":"SD/LLD/solid/#d-dependency-inversion-principle","title":"D - Dependency Inversion Principle","text":"<p>Class should depend on interfaces rather than concrete classes.</p> <p>Why Is the Dependency Inversion Principle Important</p> <p>When we write code for applications, we might split our logic into multiple modules. Nonetheless, this will result in a code with dependencies. One motivation behind DIP is to prevent us from depending upon modules that often change. Concrete classes change frequently, while abstractions and interfaces change much less. For example, operations like bug fixing, code recompiling, or merging different branches will be much easier.</p> <p>However, there is more to it. DIP is key to achieving loosely coupled and maintainable systems alongside concepts such as\u00a0Polymorphism\u00a0or\u00a0Dependency Injection.</p> <p>Let\u2019s look at the importance of DIP by observing cases where it is sometimes misplaced with other concepts.</p> <p>Must Read</p> <p>Before</p> <pre><code>classDiagram\n    class ClassB {\n        // fields, constructor and methods\n    }\n\n    class ClassA {\n        - ClassB objectB\n\n        + ClassA(ClassB objectB)\n        + void invokeClassBMethods()\n    }\n\n    ClassB &lt;-- ClassA: contains\n</code></pre> <p>After</p> <pre><code>classDiagram\n\n    class InterfaceB {\n        +method()\n    }\n\n    class ClassB {\n        // fields, constructor and methods\n    }\n\n    class ObjectA {\n        - InterfaceB objectB\n\n        + ObjectA(InterfaceB objectB)\n        ...\n    }\n\n    InterfaceB &lt;|-- ClassB : implements\n    InterfaceB &lt;-- ObjectA: contains\n</code></pre>"},{"location":"SD/LLD/Design-Patterns/","title":"Design Patterns","text":"<p>Reference</p> <p>The fundamental of every design pattern is to separate out what changes over period of time from what remains constant.</p> <pre><code>mindmap\n  root((Design Patterns))\n    Structural )Structural( \n      Composite\n      Decorator\n      Proxy\n      Bridge\n      Adapter (Adapter)\n      Facade\n      Flyweight\n    Behavioral )Behavioral(\n      Chain of Responsibility\n      Command\n      Interpreter (Interpreter)\n      Iterator\n      Mediator\n      Memento\n      Observer\n      State\n      Strategy\n      Template Method (Template Method)\n      Visitor\n    Creational )Creational(\n      Abstract Factory\n      Builder\n      Factory Method (Factory Method)\n      Prototype\n      Singleton\n\n\n</code></pre> Design Pattern Intent Observer Pattern Any change in the observable should be communicated to the observers Mediator Pattern Two classes can't communicate directly Factory Pattern Creation of an object is based on a condition"},{"location":"SD/LLD/Design-Patterns/Strategy/","title":"Strategy Design Pattern","text":"<pre><code>classDiagram\n\nclass IBrakeBehavior {\n    +brake()\n}\n\nclass BrakeWithABS {\n    +brake()\n}\n\nclass Brake {\n    +brake()\n}\n\nclass Car {\n    -brakeBehavior: IBrakeBehavior\n    +Car(IBrakeBehavior)\n    +applyBrake()\n    +setBrakeBehavior(IBrakeBehavior)\n}\n\nclass Sedan {\n    +Sedan(BrakeWithABS)\n}\n\nclass SUV {\n    +SUV(Brake)\n}\n\nIBrakeBehavior &lt;|-- BrakeWithABS\nIBrakeBehavior &lt;|-- Brake\n\nCar --&gt; IBrakeBehavior\nSedan --|&gt; Car\nSUV --|&gt; Car\n</code></pre> <pre><code>/* Encapsulated family of Algorithms\n * Interface and its implementations\n */\npublic interface IBrakeBehavior {\n    public void brake();\n}\n\npublic class BrakeWithABS implements IBrakeBehavior {\n    public void brake() {\n        System.out.println(\"Brake with ABS applied\");\n    }\n}\n\npublic class Brake implements IBrakeBehavior {\n    public void brake() {\n        System.out.println(\"Simple Brake applied\");\n    }\n}\n\n/* Client that can use the algorithms above interchangeably */\npublic abstract class Car {\n    private IBrakeBehavior brakeBehavior;\n\n    public Car(IBrakeBehavior brakeBehavior) {\n      this.brakeBehavior = brakeBehavior;\n    }\n\n    public void applyBrake() {\n        brakeBehavior.brake();\n    }\n\n    public void setBrakeBehavior(IBrakeBehavior brakeType) {\n        this.brakeBehavior = brakeType;\n    }\n}\n\n/* Client 1 uses one algorithm (Brake) in the constructor */\npublic class Sedan extends Car {\n    public Sedan() {\n        super(new Brake());\n    }\n}\n\n/* Client 2 uses another algorithm (BrakeWithABS) in the constructor */\npublic class SUV extends Car {\n    public SUV() {\n        super(new BrakeWithABS());\n    }\n}\n\n/* Using the Car example */\npublic class CarExample {\n    public static void main(final String[] arguments) {\n        Car sedanCar = new Sedan();\n        sedanCar.applyBrake();  // This will invoke class \"Brake\"\n\n        Car suvCar = new SUV();\n        suvCar.applyBrake();    // This will invoke class \"BrakeWithABS\"\n\n        // set brake behavior dynamically\n        suvCar.setBrakeBehavior( new Brake() );\n        suvCar.applyBrake();    // This will invoke class \"Brake\"\n    }\n}\n</code></pre> <p>Strategy pattern\u00a0(also known as the\u00a0policy pattern) is a\u00a0behavioral software design pattern\u00a0that enables selecting an\u00a0algorithm\u00a0at runtime. Instead of implementing a single algorithm directly, code receives runtime instructions as to which in a family of algorithms to use.</p> <p>As you see in Strategy pattern, we are trying to separate out dependency of brake from the main class  as much as possible by making various strategies to inject it dynamically based on client requirement so that in future if new requirement for brake comes, there will be minimal/no changes in existing code (Open closed Principle).</p> <p>Here in the example, we are following constructor injection. Instead of creating the brake object we are just creating a reference at Car, according to the requirement new brake object is passed at the constructor.</p> <p>Reference Site</p>"},{"location":"SD/LLD/Design-Patterns/Template/","title":"Template Design Pattern","text":"<p>When we want all classes to follow a specific order of steps to process the task but need to provide some flexibility that each class can have their own logic in that specific step.</p>"},{"location":"SD/LLD/Design-Patterns/cor/","title":"Chain Of Responsibility","text":"<p>Allows multiple handlers to process a request without the sender needing to know which handler will ultimately process it.</p>"},{"location":"SD/LLD/Design-Patterns/cor/#example-implementations","title":"Example implementations","text":"<ol> <li>Vending Machine</li> <li>ATM </li> <li>Logger in an application</li> </ol> <pre><code>classDiagram\n    class DispenseChain {\n        &lt;&lt;interface&gt;&gt;\n        +setNextChain(nextChain: DispenseChain)\n        +dispense(currency: Currency)\n    }\n\n    class Currency {\n        -amount: int\n        +Currency(amount: int)\n        +getAmount(): int\n    }\n\n    class QuarterDispenser {\n        -nextChain: DispenseChain\n        +setNextChain(nextChain: DispenseChain)\n        +dispense(currency: Currency)\n    }\n\n    class DimeDispenser {\n        -nextChain: DispenseChain\n        +setNextChain(nextChain: DispenseChain)\n        +dispense(currency: Currency)\n    }\n\n    class NickelDispenser {\n        -nextChain: DispenseChain\n        +setNextChain(nextChain: DispenseChain)\n        +dispense(currency: Currency)\n    }\n\n    class PennyDispenser {\n        -nextChain: DispenseChain\n        +setNextChain(nextChain: DispenseChain)\n        +dispense(currency: Currency)\n    }\n\n    class VendingMachine {\n        -c1: DispenseChain\n        +VendingMachine()\n        +dispense(amount: int)\n    }\n\n    DispenseChain &lt;|.. QuarterDispenser\n    DispenseChain &lt;|.. DimeDispenser\n    DispenseChain &lt;|.. NickelDispenser\n    DispenseChain &lt;|.. PennyDispenser\n\n    VendingMachine --&gt; QuarterDispenser : uses\n    VendingMachine --&gt; DimeDispenser : uses\n    VendingMachine --&gt; NickelDispenser : uses\n    VendingMachine --&gt; PennyDispenser : uses\n\n    QuarterDispenser --&gt; DispenseChain : sets next\n    DimeDispenser --&gt; DispenseChain : sets next\n    NickelDispenser --&gt; DispenseChain : sets next\n    PennyDispenser --&gt; DispenseChain : sets next\n\n    QuarterDispenser --&gt; Currency : dispenses\n    DimeDispenser --&gt; Currency : dispenses\n    NickelDispenser --&gt; Currency : dispenses\n    PennyDispenser --&gt; Currency : dispenses\n</code></pre> <pre><code>classDiagram\n    class DispenseChain {\n        &lt;&lt;interface&gt;&gt;\n        +setNextChain(nextChain: DispenseChain)\n        +dispense(currency: Currency)\n    }\n\n    class Currency {\n        -amount: int\n        +Currency(amount: int)\n        +getAmount(): int\n    }\n\n    class VendingMachine {\n        -c1: DispenseChain\n        +VendingMachine()\n        +dispense(amount: int)\n    }\n\n    class CoinDispenser {\n        -nextDispenser: CoinDispenser\n        +setNextDispenser(nextDispenser: CoinDispenser)\n        +dispense(currency: Currency)\n    }\n\n    VendingMachine \"1\" --&gt; \"1\" DispenseChain\n    DispenseChain &lt;|.. CoinDispenser\n    CoinDispenser --&gt; CoinDispenser : sets next\n    CoinDispenser --&gt; Currency : dispenses\n</code></pre>"},{"location":"SD/LLD/Design-Patterns/mediator/","title":"Mediator Design Pattern","text":"<p>It encourages loose coupling by keeping objects from referring to each other explicitly and allows them to communicate through a mediator object.</p> <p>Examples</p> <ol> <li>Airline Management System</li> <li>Chat Application</li> <li>Online Auction Management</li> </ol> <p>This diagram includes the Auction Mediator pattern with the general components like <code>AuctionMediator</code>, <code>Auction</code>, <code>Bidder</code>, and <code>ConcreteBidder</code>.</p> <pre><code>classDiagram\n    AuctionMediator &lt;|-- Auction\n    Bidder &lt;|-- ConcreteBidder\n\n    class AuctionMediator {\n        &lt;&lt;interface&gt;&gt;\n        +registerBidder(bidder: Bidder)\n        +placeBid(bidder: Bidder, amount: double)\n        +notifyBidders()\n    }\n\n    class Auction {\n        -List~Bidder~ bidders\n        -Bidder highestBidder\n        -double highestBid\n        +registerBidder(bidder: Bidder)\n        +placeBid(bidder: Bidder, amount: double)\n        +notifyBidders()\n    }\n\n    class Bidder {\n        &lt;&lt;interface&gt;&gt;\n        +update(highestBid: double, highestBidder: Bidder)\n        +placeBid(amount: double)\n        +getName(): String\n    }\n\n    class ConcreteBidder {\n        -String name\n        -AuctionMediator mediator\n        +ConcreteBidder(name: String, mediator: AuctionMediator)\n        +update(highestBid: double, highestBidder: Bidder)\n        +placeBid(amount: double)\n        +getName(): String\n    }\n\n    AuctionMediator o-- Bidder\n    Auction o-- ConcreteBidder\n    ConcreteBidder --|&gt; Bidder\n    Auction --|&gt; AuctionMediator\n</code></pre> <p>Explanation of the Diagram</p> <ol> <li>AuctionMediator: This is an interface that declares methods to register bidders, place bids, and notify bidders.</li> <li>Auction: This is the concrete mediator class that implements the <code>AuctionMediator</code> interface. It maintains a list of bidders, tracks the highest bid and the highest bidder, and notifies bidders of updates.</li> <li>Bidder: This is an interface that declares methods for updating bidders, placing bids, and getting the bidder's name.</li> <li>ConcreteBidder: This is a concrete implementation of the <code>Bidder</code> interface. It interacts with the <code>AuctionMediator</code> to place bids and get notified of bid updates.</li> </ol>"},{"location":"SD/LLD/Design-Patterns/memento/","title":"Memento Design Pattern","text":"<p>Its a behavioural design pattern</p> <p>Why its required and when to use : Provides an ability to revert the an object to a previous state i.e., UNDO capability</p> <p>It doesn\u2019t expose the object internal implementation</p>"},{"location":"SD/Machine%20Coding/Rules/","title":"Rules","text":"<p>Taken From / Reference</p> <p>A keen sense of design, focusing on extensibility, performance, and scalability. </p> <p>Best Practice:\u00a0Create a proper folder structure: one folder for models, another for the storage layer, and one for the business logic layer. This structure not only keeps your code clean and maintainable but also demonstrates to the interviewer that you have experience with professional coding practices.</p> <p>Don\u2019t write entire code in a single file</p> <p>Solution:\u00a0Store references (IDs) rather than entire objects to make your models lightweight and avoid unnecessary dependencies. Using UUIDs is an excellent practice, especially for distributed systems, as it helps with unique identification across platforms.</p> <p>A better approach is to separate business logic from data representation by introducing a dedicated service class.</p> <p>Correct Approach:\u00a0Keep business logic in a separate service class, like\u00a0<code>BookingService</code>, while model classes should handle only data. This separation of concerns makes the code more scalable, readable, and maintainable.</p> <p>There is no actual database integration required; all implementations should be done in-memory</p> <p>Candidates often lack experience with implementing efficient in-memory storage. For instance, using a\u00a0<code>List</code>\u00a0to store user data is inefficient if you frequently need to look up users by ID, as it requires a full list traversal.</p> <p>Solution Code: Using a Map for Efficient Lookup. Use a\u00a0<code>Map</code>\u00a0(or dictionary) for O(1) key-based lookups, which is much faster and more efficient for large datasets. This is a simple adjustment that can significantly improve your code's efficiency.</p> <p>To enhance flexibility, we can introduce an interface for the storage mechanism:</p> <pre><code>// Define an interface for User storage\ninterface UserStorage {\n    void save(User user);\n    User findById(String userId);\n}\n\n// In-memory implementation of UserStorage\nclass InMemoryUserDao implements UserStorage {\n    @Override\n    public void save(User user) {\n        // Logic to save user to in-memory storage\n    }\n\n    @Override\n    public User findById(String userId) {\n        return new User(userId, \"John Doe\"); // Sample user\n    }\n}\n\n// UserService now uses UserStorage interface\nclass UserService {\n    private UserStorage userStorage;\n\n    public UserService(UserStorage userStorage) {\n        this.userStorage = userStorage; // Loosely coupled\n    }\n\n    public void registerUser(User user) {\n        userStorage.save(user);\n    }\n\n    public User getUser(String userId) {\n        return userStorage.findById(userId);\n    }\n}\n</code></pre> <p>A red flag for interviewers is raw exceptions or minimal logging without proper error handling. Without a structured error-handling approach, your code becomes harder to debug, and there is no meaningful feedback to handle failures gracefully.</p> <p>Instead of throwing generic exceptions, create custom exceptions, like\u00a0<code>UserNotFoundException</code>, that provide more detailed error context. Structured error handling also allows you to take corrective action, log the error meaningfully, or display an error message to the user if needed.</p> <p>Many candidates overlook the use of basic design patterns (e.g., Factory, Singleton, etc) and SOLID principles. These patterns and principles make the code reusable and maintainable, reducing redundancy and making it easier to scale. Following SOLID principles \u2014 Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, and Dependency Inversion \u2014 ensures you\u2019re ready to handle complex systems effectively.</p> <p>Not having a strong grasp of core programming concepts can also hurt your chances. Some essential concepts to brush up on include:</p> <ul> <li>Shallow Copy vs. Deep Copy:\u00a0Understand the difference, as this affects object references and memory management.</li> <li>String Mutability:\u00a0Knowing when and how to use immutable data structures like strings.</li> <li>Locking Mechanisms:\u00a0Be aware of optimistic and pessimistic locking for handling concurrency in multi-threaded environments.</li> </ul>"},{"location":"SD/Machine%20Coding/SnakeAndLadders/","title":"Snake & Ladders","text":"Board.java<pre><code>package SnakeAndLadder;\n\nimport java.util.HashMap;\n\npublic class Board {\n    private final HashMap&lt;Integer, Integer&gt; snakes;\n    private final HashMap&lt;Integer, Integer&gt; ladders;\n    private final int numOfCells;\n     public Board(int numOfCells){\n         snakes = new HashMap&lt;&gt;();\n         ladders = new HashMap&lt;&gt;();\n         this.numOfCells = numOfCells;\n     }\n\n    public int getNumOfCells() {\n        return numOfCells;\n    }\n\n    public void addSnake(int start, int end){\n         if(start &lt;= end) {\n             System.out.println(\"Snake should have start position greater than end\");\n         }\n         snakes.put(start,end);\n     }\n    public void addLadder(int start, int end){\n        if(start &gt;= end) {\n            System.out.println(\"Ladder should have start position less than end\");\n        }\n        ladders.put(start,end);\n    }\n\n    public int updatePlayerPosition(Player player, int diceVal){\n         int currentPlayerPosition = player.getCurrentPos();\n         int expectedPosition = currentPlayerPosition + diceVal;\n\n         if(expectedPosition&gt;numOfCells){\n             expectedPosition = numOfCells;\n         }\n         else if(snakes.containsKey(expectedPosition)){\n             System.out.println(player.getName() +\": is bitten by a snake at \"+expectedPosition);\n             expectedPosition = snakes.get(expectedPosition);\n         }\n         else if(ladders.containsKey(expectedPosition)) {\n             System.out.println(player.getName() + \": climbed a ladder at \" + expectedPosition);\n             expectedPosition = ladders.get(expectedPosition);\n         }\n         player.setCurrentPos(expectedPosition);\n         System.out.println(player.getName() + \": moved to \" + expectedPosition);\n         return expectedPosition;\n    }\n\n}\n</code></pre> Game.java<pre><code>package SnakeAndLadder;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\n\npublic class Game {\n    List&lt;Player&gt; playerList;\n    Random random;\n    Board board;\n    public Game(int numOfCells){\n        playerList = new ArrayList&lt;&gt;();\n        random = new Random();\n        board = new Board(numOfCells);\n    }\n\n    public void createPlayer(String name){\n        Player player = new Player(name);\n        playerList.add(player);\n    }\n\n    public void addSnakeToBoard(int startPos, int endPos){\n        board.addSnake(startPos,endPos);\n    }\n    public void addLadderToBoard(int startPos, int endPos){\n        board.addLadder(startPos,endPos);\n    }\n\n    public void startGame(){\n        System.out.println(\"!!!!!!!!!!!!!!!!!!!GAME STARTED !!!!!!!!!!!!!\");\n        int currentPlayerIndex = 0;\n        Player currentPlayer;\n        while(true){\n            currentPlayer = playerList.get(currentPlayerIndex);\n            // throwing a dice\n            int diceValue = random.nextInt(6)+1;\n            System.out.println(currentPlayer.getName()+\": thrown the dice --&gt; \"+diceValue);\n            // update player position\n            int updatedPlayerPos = board.updatePlayerPosition(currentPlayer,diceValue);\n            // check if the player has finished the game\n            if(updatedPlayerPos==board.getNumOfCells()){\n                System.out.println(currentPlayer.getName()+\": won the game!!!\");\n                break;\n            }\n            // get next player index\n            currentPlayerIndex = (currentPlayerIndex+1)%(playerList.size());\n        }\n        System.out.println(\"!!!!!!!!!!!!!!!!!!!GAME OVER !!!!!!!!!!!!!\");\n    }\n}\n</code></pre> Main.java<pre><code>package SnakeAndLadder;\n\npublic class Main {\n    public static void main(String[] args) {\n        // create a game\n        Game game = new Game(100);\n\n        // add players\n        game.createPlayer(\"Maneesh Gupta\");\n        game.createPlayer(\"Lokesh\");\n        game.createPlayer(\"Bhargav\");\n\n        // add snakes\n        game.addSnakeToBoard(21,12);\n        game.addSnakeToBoard(13,11);\n        game.addSnakeToBoard(1,2);\n\n        // add ladders\n        game.addLadderToBoard(2,12);\n        game.addLadderToBoard(9,19);\n\n        game.startGame();\n    }\n}\n</code></pre> Player.java<pre><code>package SnakeAndLadder;\n\npublic class Player {\n    private String name;\n    private int currentPos;\n\n    public Player(String name) {\n        this.name = name;\n        currentPos = 1;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public void setCurrentPos(int currentPos) {\n        this.currentPos = currentPos;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public int getCurrentPos() {\n        return currentPos;\n    }\n}\n</code></pre>"},{"location":"SD/Machine%20Coding/Splitwise/","title":"Splitwise","text":""},{"location":"SD/Machine%20Coding/Splitwise/#problem-statement","title":"Problem Statement","text":"<p>Design and implement an in Memory Expense sharing application where users should be able to add expenses and split it among users. Eg - Splitwise</p> <ol> <li>User should be able to add expense which could be divided equally, in percent or exact. For now only splitting equally would work.</li> <li>Expose a function to get all the expense added by user.</li> <li>Expose a function to get balance of a user.</li> <li>Expose a function to get all the expense where the user is part of. </li> <li>The function to create expense should be able to lake get extra data as per expense type. </li> <li>For interview we need only equal and exact split to be implemented but solution should beextendible for other type of expense. </li> <li>In case of exact, it should throw error if sum of shares is not equal to total.</li> </ol>"},{"location":"SD/Machine%20Coding/Splitwise/#approach","title":"Approach","text":"<ul> <li>Interface for Split Calculation: Define an interface <code>SplitStrategy</code> to handle various splitting logic. Each type (e.g., <code>EqualSplit</code>, <code>PercentageSplit</code>, <code>ExactSplit</code>) implements this interface.</li> <li>Expense Class: Modularize expense creation by leveraging the <code>SplitStrategy</code>.</li> <li>SplitType Enum with Factory: Use a factory pattern to map <code>SplitType</code> to the appropriate <code>SplitStrategy</code>.</li> <li>Validation: Add checks for invalid cases like percentage not summing up to 100 or actual amounts not summing up to the total expense.</li> </ul>"},{"location":"SD/Machine%20Coding/Splitwise/#code","title":"Code","text":"User.java<pre><code>package splitwise;\n\npublic class User {\n    private final String id;\n    private final String name;\n\n    public User(String id, String name) {\n        this.id = id;\n        this.name = name;\n    }\n    public String getId() {\n        return id;\n    }\n    @Override\n    public String toString() {\n        return name;\n    }\n}\n</code></pre> Expense.java<pre><code>package splitwise;\n\nimport java.util.List;\nimport java.util.Map;\n\npublic class Expense {\n    private final String expenseId;\n    private final double amount;\n    private final User payer;\n    private final List&lt;User&gt; participants;\n\n    public List&lt;User&gt; getParticipants() {\n        return participants;\n    }\n\n    private final Map&lt;User, Double&gt; splits;\n\n    public Expense(String expenseId, double amount, User payer, List&lt;User&gt; participants, Map&lt;User, Double&gt; splits) {\n        this.expenseId = expenseId;\n        this.amount = amount;\n        this.payer = payer;\n        this.participants = participants;\n        this.splits = splits;\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder builder = new StringBuilder();\n        builder.append(\"Expense ID: \").append(expenseId).append(\"\\n\")\n                .append(\"Payer: \").append(payer).append(\"\\n\")\n                .append(\"Amount: \").append(amount).append(\"\\n\")\n                .append(\"Participants: \");\n\n        for (User participant : participants) {\n            builder.append(participant).append(\", \");\n        }\n        if (!participants.isEmpty()) {\n            builder.setLength(builder.length() - 2); // Remove trailing comma and space\n        }\n\n        builder.append(\"\\nSplits: \\n\");\n        for (Map.Entry&lt;User, Double&gt; entry : splits.entrySet()) {\n            builder.append(\"  \").append(entry.getKey())\n                    .append(\": \").append(String.format(\"%.2f\", entry.getValue()))\n                    .append(\"\\n\");\n        }\n\n        return builder.toString();\n    }\n\n}\n</code></pre> ExpenseManager.java<pre><code>package splitwise;\n\nimport splitwise.splitstrategy.SplitType;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\npublic class ExpenseManager {\n    private final Map&lt;String, List&lt;Expense&gt;&gt; userExpenses = new HashMap&lt;&gt;();\n    private final Map&lt;String, Map&lt;String, Double&gt;&gt; userBalances = new HashMap&lt;&gt;();\n\n    public void addExpense(String expenseId, double amount, User payer, List&lt;User&gt; participants, SplitType splitType, Map&lt;User, Double&gt; metaData) {\n        Map&lt;User, Double&gt; splits = splitType.getStrategy().calculateSplits(amount, participants, metaData);\n\n        Expense expense = new Expense(expenseId, amount, payer, participants, splits);\n        userExpenses.computeIfAbsent(payer.getId(), k -&gt; new ArrayList&lt;&gt;()).add(expense);\n\n        for (Map.Entry&lt;User, Double&gt; entry : splits.entrySet()) {\n            User participant = entry.getKey();\n            double share = entry.getValue();\n            if (!participant.getId().equals(payer.getId())) {\n                userBalances.computeIfAbsent(participant.getId(), k -&gt; new HashMap&lt;&gt;())\n                        .merge(payer.getId(), share, Double::sum);\n                userBalances.computeIfAbsent(payer.getId(), k -&gt; new HashMap&lt;&gt;())\n                        .merge(participant.getId(), -share, Double::sum);\n            }\n        }\n    }\n\n    public List&lt;Expense&gt; getUserExpenses(String userId) {\n        return userExpenses.getOrDefault(userId, new ArrayList&lt;&gt;());\n    }\n\n    public String getUserBalance(String userId) {\n        Map&lt;String, Double&gt; userBalanceMap = userBalances.get(userId);\n\n        if (userBalanceMap == null || userBalanceMap.isEmpty()) {\n            return \"No balances found for user with ID: \" + userId;\n        }\n\n        StringBuilder builder = new StringBuilder();\n        builder.append(\"Balance for user ID: \").append(userId).append(\"\\n\");\n        for (Map.Entry&lt;String, Double&gt; entry : userBalanceMap.entrySet()) {\n            String otherUserId = entry.getKey();\n            double balance = entry.getValue();\n            builder.append(\"  With User ID: \").append(otherUserId)\n                    .append(\" -&gt; \").append(balance &gt;= 0 ? \"Owes \" : \"Owed \")\n                    .append(String.format(\"%.2f\", Math.abs(balance)))\n                    .append(\"\\n\");\n        }\n        return builder.toString();\n    }\n\n\n    public String getAllUserInvolvedExpenses(String userId) {\n        List&lt;Expense&gt; expenses = new ArrayList&lt;&gt;();\n        userExpenses.values().forEach(expense -&gt;\n                expense.stream()\n                        .filter(e -&gt; e.toString().contains(userId))\n                        .forEach(expenses::add));\n        List&lt;Expense&gt; userExpenses = expenses.stream()\n                .filter(expense -&gt; expense.getParticipants().stream()\n                        .anyMatch(participant -&gt; participant.getId().equals(userId)))\n                .collect(Collectors.toList());\n\n        if (expenses.isEmpty()) {\n            return \"No expenses found for user with ID: \" + userId;\n        }\n\n        StringBuilder builder = new StringBuilder();\n        builder.append(\"Expenses involving user ID: \").append(userId).append(\"\\n\");\n        for (Expense expense : userExpenses) {\n            builder.append(expense.toString()).append(\"\\n\");\n        }\n        return builder.toString();\n    }\n}\n</code></pre> SplitStrategy.java<pre><code>package splitwise.splitstrategy;\n\nimport splitwise.User;\n\nimport java.util.List;\nimport java.util.Map;\n\n public interface SplitStrategy {\n    Map&lt;User, Double&gt; calculateSplits(double totalAmount, List&lt;User&gt; participants, Map&lt;User, Double&gt; metaData);\n}\n</code></pre> EqualSplit.java<pre><code>package splitwise.splitstrategy;\n\nimport splitwise.User;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class EqualSplit implements SplitStrategy {\n    @Override\n    public Map&lt;User, Double&gt; calculateSplits(double totalAmount, List&lt;User&gt; participants, Map&lt;User, Double&gt; metaData) {\n        double splitAmount = totalAmount / participants.size();\n        Map&lt;User, Double&gt; splits = new HashMap&lt;&gt;();\n        for (User participant : participants) {\n            splits.put(participant, splitAmount);\n        }\n        return splits;\n    }\n}\n</code></pre> ExactSplit.java<pre><code>package splitwise.splitstrategy;\n\nimport splitwise.User;\nimport java.util.*;\n\npublic class ExactSplit implements SplitStrategy {\n    @Override\n    public Map&lt;User, Double&gt; calculateSplits(double totalAmount, List&lt;User&gt; participants, Map&lt;User, Double&gt; metaData) {\n        double totalSplit = metaData.values().stream().mapToDouble(Double::doubleValue).sum();\n        if (totalSplit != totalAmount) {\n            throw new IllegalArgumentException(\"Exact amounts must sum up to the total amount.\");\n        }\n\n        Map&lt;User, Double&gt; splits = new HashMap&lt;&gt;();\n        for (User participant : participants) {\n            splits.put(participant, metaData.getOrDefault(participant, 0.0));\n        }\n        return splits;\n    }\n}\n</code></pre> PercentageSplit.java<pre><code>package splitwise.splitstrategy;\n\nimport splitwise.User;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class PercentageSplit implements SplitStrategy {\n    @Override\n    public Map&lt;User, Double&gt; calculateSplits(double totalAmount, List&lt;User&gt; participants, Map&lt;User, Double&gt; metaData) {\n        double totalPercentage = metaData.values().stream().mapToDouble(Double::doubleValue).sum();\n        if (totalPercentage != 100.0) {\n            throw new IllegalArgumentException(\"Percentages must sum up to 100.\");\n        }\n\n        Map&lt;User, Double&gt; splits = new HashMap&lt;&gt;();\n        for (User participant : participants) {\n            double percentage = metaData.getOrDefault(participant, 0.0);\n            splits.put(participant, (percentage / 100) * totalAmount);\n        }\n        return splits;\n    }\n}\n</code></pre> SplitType.java<pre><code>package splitwise.splitstrategy;\n\npublic enum SplitType {\n    EQUAL(new EqualSplit()),\n    PERCENTAGE(new PercentageSplit()),\n    EXACT(new ExactSplit());\n\n    private final SplitStrategy strategy;\n\n    SplitType(SplitStrategy strategy) {\n        this.strategy = strategy;\n    }\n\n    public SplitStrategy getStrategy() {\n        return strategy;\n    }\n}\n</code></pre> ExpenseSharingApp.java<pre><code>package splitwise;\nimport splitwise.splitstrategy.SplitType;\n\nimport java.util.*;\npublic class ExpenseSharingApp {\n    public static void main(String[] args) {\n        User user1 = new User(\"1\", \"Alice\");\n        User user2 = new User(\"2\", \"Bob\");\n        User user3 = new User(\"3\", \"Charlie\");\n\n        ExpenseManager manager = new ExpenseManager();\n\n        // Equal Split\n        manager.addExpense(\"exp1\", 300, user1, Arrays.asList(user1, user2, user3), SplitType.EQUAL, new HashMap&lt;&gt;());\n        System.out.println(\"Expenses added by Alice:\");\n        System.out.println(manager.getUserExpenses(user1.getId()));\n\n        // Percentage Split\n        Map&lt;User, Double&gt; percentageMetaData = new HashMap&lt;&gt;();\n        percentageMetaData.put(user2, 50.0);\n        percentageMetaData.put(user3, 50.0);\n        manager.addExpense(\"exp2\", 200, user1, Arrays.asList(user1, user2, user3), SplitType.PERCENTAGE, percentageMetaData);\n        System.out.println(\"\\nExpenses added by Alice (Percentage Split):\");\n        System.out.println(manager.getUserExpenses(user1.getId()));\n\n        // Exact Split\n        Map&lt;User, Double&gt; exactMetaData = new HashMap&lt;&gt;();\n        exactMetaData.put(user2, 100.0);\n        exactMetaData.put(user3, 100.0);\n        manager.addExpense(\"exp3\", 200, user1, Arrays.asList(user1, user2, user3), SplitType.EXACT, exactMetaData);\n        System.out.println(\"\\nExpenses added by Alice (Exact Split):\");\n        System.out.println(manager.getUserExpenses(user1.getId()));\n\n        // Get balances\n        System.out.println(\"\\nBalance of Bob:\");\n        System.out.println(manager.getUserBalance(user2.getId()));\n\n        System.out.println(\"\\nAll expenses where Charlie is involved:\");\n        System.out.println(manager.getAllUserInvolvedExpenses(user3.getId()));\n    }\n}\n</code></pre>"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/2024/08/06/hello-world/","title":"Hello World","text":"<p>Today I learnt a documentation site. I want to learn more about it.</p>","tags":["intro","posts"]},{"location":"blog/2024/01/31/second-post/","title":"Second Post","text":"<p>Sample second blog posts.</p>","tags":["intro","posts"]},{"location":"java/","title":"Java","text":"<pre><code>mindmap\n  root)Java Data Types(\n    Primitive Data Types \n      Number\n        Integer Types\n          byte {{byte}}\n          short {{short}}\n          int {{int}}\n          long {{ long}}\n        Floating-Point Types\n          float {{float}}\n          double {{double}}\n      Character Type\n        char {{char}}\n      Boolean Type\n        boolean {{ boolean}}\n    Non-Primitive Data Types\n      Class\n        String\n        Arrays\n      Interface\n      Enum\n      Arrays</code></pre>"},{"location":"java/#classes","title":"Classes","text":"<ol> <li>Concrete Class</li> <li>Abstract Class</li> <li>Super class and sub class</li> <li>Object Class</li> <li>Nested Classes<ol> <li>Inner class ( Non static nested class)</li> <li>Anonymous Inner Class</li> <li>Member Inner Class</li> <li>Local Inner Class</li> <li>Static Nested Class / Static Class</li> </ol> </li> <li>Generic Class</li> <li>POJO Class</li> <li>Enum Class</li> <li>Final Class</li> <li>Singleton Class</li> <li>Immutable Class</li> <li>Wrapper Class</li> </ol>"},{"location":"java/hashmap/","title":"HashMap","text":"<ol> <li>Java HashMap allows null key, which always goes to index 0 as hash of null is 0.</li> <li>Default size of HashMap is 16.</li> <li>In Java 8, when we have too many unequals keys gives the same hashCode(index) value i.e, when the number of entries in the same hash bucket exceeds a threshold value ( <code>TREEIFY_THRESHOLD=8</code> ), contents of that bucket switches from linked list of entry objects to a balanced binary tree. This theoretically improves the performance from <code>O(n)</code> to <code>O(logn)</code> .</li> </ol>"},{"location":"java/questions/","title":"Interview Questions","text":"<ol> <li>What is the significance of <code>volatile</code> keyword in JAVA?</li> <li>Difference between <code>StringBuffer</code> and <code>StringBuilder</code> ?</li> <li>Why is there only one public class in a java file</li> <li>How and where to use <code>transient</code> keyword?</li> <li>How Java program works and 3 important components (JVM, JRE, JDK)</li> <li>Difference between <code>HashMap</code> and <code>HashTable</code> ?</li> <li>What is the difference in the internal working of <code>HashMap</code> and <code>ConcurrentHashMap</code></li> <li>Difference between <code>Runnable</code> and <code>Callable</code> ?</li> <li><code>final</code> , <code>finally</code> and <code>finalize</code> ?</li> </ol>"},{"location":"java/java-8-features/java-8-features/","title":"Java 8 Features","text":"<ol> <li>Optional</li> <li>Streams</li> <li>Lambda Expressions</li> </ol>"},{"location":"java/java-8-features/examples/example1/","title":"Example1","text":""},{"location":"java/java-8-features/examples/example1/#sample-example","title":"Sample Example","text":""},{"location":"java/threads/intro/","title":"Threads Basics","text":"<p>A thread can be created using 2 methods - extending thread class - implementing runnable interface</p> <p>Runnable interface is a functional interface. <pre><code>classDiagram\n    class Runnable {\n        &lt;&lt;interface&gt;&gt;\n        +run()\n    }\n\n    class Thread {\n        +start()\n        +run()\n        +join()\n        +sleep(long millis)\n        +currentThread()\n        +getName()\n        +setName(String name)\n        +getId()\n        +getState()\n        +interrupt()\n        +isInterrupted()\n    }\n\n    Runnable &lt;|.. Thread\n</code></pre></p> <pre><code>---\ntitle: Thread Life Cycle\n---\nstateDiagram-v2\ndirection LR\n    [*] --&gt; New\n    New --&gt; Terminated\n        New --&gt; Active\n        state Active{\n            direction LR\n            Runnable--&gt;Running : run\n            Running--&gt;Runnable : yield\n        }\n        Active --&gt; Blocked\n        Blocked --&gt; Active\n        Active --&gt; Waiting\n        Waiting --&gt; Active\n        Active --&gt; TimedWaiting\n        TimedWaiting --&gt; Active\n\n      Blocked --&gt; Terminated\n      TimedWaiting --&gt; Terminated\n      Waiting --&gt; Terminated\n    Active --&gt; Terminated\n    Terminated --&gt; [*]\n</code></pre>"},{"location":"springboot/","title":"Spring Boot Page","text":"<p>Info</p> <p>To read about Gradle</p>"},{"location":"springboot/sample-questions/","title":"Interview Questions","text":"<p>Interceptors &amp; Filters</p> <p>1000 interceptor </p>","tags":["java","spring"]},{"location":"blog/archive/2024/","title":"2024","text":""},{"location":"blog/category/documentation/","title":"Documentation","text":""},{"location":"blog/category/second/","title":"Second","text":""},{"location":"tags/","title":"Tags","text":""},{"location":"tags/#leetcode","title":"Leetcode","text":"<ul> <li>LC714 - Buy and Sell Stocks With Transaction Fee</li> </ul>"},{"location":"tags/#cache","title":"cache","text":"<ul> <li>Caching Strategy</li> </ul>"},{"location":"tags/#concurrency","title":"concurrency","text":"<ul> <li>Concurrency</li> </ul>"},{"location":"tags/#dsa","title":"dsa","text":"<ul> <li>Graph Topics</li> <li>Trees</li> </ul>"},{"location":"tags/#graph","title":"graph","text":"<ul> <li>Graph Topics</li> </ul>"},{"location":"tags/#hld","title":"hld","text":"<ul> <li>Caching Strategy</li> <li>Concurrency</li> <li>Load Balancing</li> </ul>"},{"location":"tags/#intro","title":"intro","text":"<ul> <li>Home</li> <li>Hello World</li> <li>Second Post</li> </ul>"},{"location":"tags/#java","title":"java","text":"<ul> <li>Interview Questions</li> </ul>"},{"location":"tags/#loadbalancing","title":"loadbalancing","text":"<ul> <li>Load Balancing</li> </ul>"},{"location":"tags/#posts","title":"posts","text":"<ul> <li>Hello World</li> <li>Second Post</li> </ul>"},{"location":"tags/#spring","title":"spring","text":"<ul> <li>Interview Questions</li> </ul>"},{"location":"tags/#tree","title":"tree","text":"<ul> <li>Trees</li> </ul>"}]}